---
import { ArrowUturnLeftIcon } from "@heroicons/react/16/solid";
import { CodeIcon } from "@radix-ui/react-icons";
import { getCollection } from "astro:content";

const work = await getCollection("work");
const workSorted = work.sort((a, b) => {
  return new Date(a.data.date).getTime() - new Date(b.data.date).getTime();
});

// Prepare image data for client-side use
const workImageData = workSorted
  .filter((post) => post.data.published)
  .map((post) => ({
    id: post.id,
    title: post.data.title,
    image: post.data.image,
  }));

// Check if current path is home page
const isHomePage = Astro.url.pathname === "/";
---

<section class="md:fixed bottom-4 left-8">
  {
    isHomePage ? (
      <div>
        <h2 data-animation-type="line">Work</h2>
        <ul class="link-selection" id="work-list">
          {workSorted
            .filter((post) => post.data.published)
            .map((post) => (
              <li class="group work-item">
                <h3>
                  <a
                    href={`/${post.id}`}
                    class="work-link flex items-center gap-2 group-hover:text-[var(--color-accent)] transition-colors duration-300"
                    data-post-id={post.id}
                  >
                    <CodeIcon className="group-hover:text-[var(--color-accent)] transition-colors duration-300" />
                    {post.data.title}
                  </a>
                </h3>
              </li>
            ))}
        </ul>
      </div>
    ) : (
      <div>
        <h2 data-animation-type="line">
          <a
            href="/"
            class="hidden md:flex group items-center gap-2 hover:text-[var(--color-text)] transition-colors duration-300"
          >
            <ArrowUturnLeftIcon className="w-4 h-4 group-hover:text-[var(--color-text)] group-hover:-translate-x-0.5 transition-all duration-300" />{" "}
            Back
          </a>
          <span class="md:hidden">Work</span>
        </h2>
        <ul class="link-selection md:hidden">
          {workSorted
            .filter(
              (post) =>
                post.data.published &&
                `/${post.id}` !== Astro.url.pathname.replace(/\/$/, "")
            )
            .map((post) => (
              <li class="group work-item">
                <h3>
                  <a
                    href={`/${post.id}`}
                    class="work-link flex items-center gap-2 group-hover:text-[var(--color-accent)] transition-colors duration-300"
                    data-post-id={post.id}
                  >
                    <CodeIcon />
                    {post.data.title}
                  </a>
                </h3>
              </li>
            ))}
        </ul>
      </div>
    )
  }
</section>

<!-- Hover image container -->
<div
  id="hover-image-container"
  class="hidden md:flex fixed inset-0 pointer-events-none z-10 items-center justify-center translate-y-4 opacity-100 transition-all duration-300"
>
  <!-- Images will be loaded dynamically on first hover -->
</div>

<script define:vars={{ workImageData }}>
  // Track loaded images for lazy loading
  let loadedImages = new Set();
  let hoverImages = [];
  let isInitialized = false;

  // Function to load image on first hover
  function loadImage(postId) {
    if (loadedImages.has(postId)) return;

    const post = workImageData.find((p) => p.id === postId);
    if (!post) return;

    const hoverContainer = document.getElementById("hover-image-container");
    if (!hoverContainer) return;

    const img = document.createElement("img");
    img.src = post.image.src;
    img.alt = post.title;
    img.className =
      "w-[90vw] lg:w-[75vw] xl:w-[60vw] h-auto rounded-xl work-hover-image absolute opacity-0 transition-all duration-300 saturate-20 brightness-75 shadow-none";
    img.setAttribute("data-post-id", postId);

    hoverContainer.appendChild(img);
    hoverImages.push(img);
    loadedImages.add(postId);
  }

  // Function to clean up hover system
  function cleanupHoverSystem() {
    // Remove all hover images
    const hoverContainer = document.getElementById("hover-image-container");
    if (hoverContainer) {
      hoverContainer.innerHTML =
        "<!-- Images will be loaded dynamically on first hover -->";
    }

    // Reset state
    loadedImages.clear();
    hoverImages = [];
    isInitialized = false;
  }

  // Function to attach hover event listeners
  function attachHoverListeners() {
    // Prevent multiple initializations
    if (isInitialized) return;

    // Only attach listeners on medium screens and above
    if (window.innerWidth < 768) return;

    const workLinks = document.querySelectorAll(".work-link");
    const hoverContainer = document.getElementById("hover-image-container");
    const workList = document.getElementById("work-list");

    if (hoverContainer && workList) {
      // Work list hover - controls translate animation
      workList.addEventListener("mouseenter", () => {
        hoverContainer.classList.remove("translate-y-4");
        hoverContainer.classList.add("translate-y-0");
      });

      workList.addEventListener("mouseleave", () => {
        hoverContainer.classList.remove("translate-y-0");
        hoverContainer.classList.add("translate-y-4");
      });

      // Individual link hovers - control image opacity
      workLinks.forEach((link) => {
        const postId = link.getAttribute("data-post-id");
        if (!postId) return;

        link.addEventListener("mouseenter", () => {
          // Load image if not already loaded
          loadImage(postId);

          // Hide all images first
          hoverImages.forEach((img) => {
            img.classList.remove(
              "opacity-100",
              "shadow-[0_0_30px_var(--color-bg)]"
            );
            img.classList.add("opacity-0", "shadow-none");
          });

          // Show the corresponding image
          const targetImage = document.querySelector(
            `.work-hover-image[data-post-id="${postId}"]`
          );
          if (targetImage) {
            targetImage.classList.remove("opacity-0", "shadow-none");
            targetImage.classList.add(
              "opacity-100",
              "shadow-[0_0_30px_var(--color-bg)]"
            );
          }
        });

        link.addEventListener("mouseleave", () => {
          // Hide all images when leaving a link
          hoverImages.forEach((img) => {
            img.classList.remove(
              "opacity-100",
              "shadow-[0_0_30px_var(--color-bg)]"
            );
            img.classList.add("opacity-0", "shadow-none");
          });
        });
      });

      isInitialized = true;
    }
  }

  // Attach listeners on initial page load
  attachHoverListeners();

  // Clean up and re-attach listeners after view transitions
  document.addEventListener("astro:page-load", () => {
    cleanupHoverSystem();
    // Small delay to ensure DOM is ready
    setTimeout(attachHoverListeners, 50);
  });

  // Re-attach listeners on window resize (in case user rotates device)
  window.addEventListener("resize", () => {
    if (window.innerWidth >= 768) {
      cleanupHoverSystem();
      attachHoverListeners();
    }
  });

  // Work menu animation system
  function animateWorkMenu() {
    const workItems = document.querySelectorAll(".work-item");
    const viewportHeight = window.innerHeight;

    workItems.forEach((item, index) => {
      const htmlItem = item;
      const rect = htmlItem.getBoundingClientRect();
      const isInViewport = rect.top < viewportHeight && rect.bottom > 0;

      if (isInViewport) {
        // Element is in viewport - stagger animate it
        setTimeout(() => {
          htmlItem.classList.add("animate-visible");
        }, index * 100); // Stagger by 100ms
      } else {
        // Element is not in viewport - set up for intersection observer
        htmlItem.dataset.animationType = "content";
      }
    });
  }

  // Set up intersection observer for work items not in initial viewport
  function setupWorkObserver() {
    const observerOptions = {
      threshold: 0.3,
      rootMargin: "0px 0px -50px 0px",
    };

    const workObserver = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          const element = entry.target;
          element.classList.add("animate-visible");
          workObserver.unobserve(element);
        }
      });
    }, observerOptions);

    // Observe work items that need animation
    const workItems = document.querySelectorAll(".work-item");
    workItems.forEach((item) => {
      const htmlItem = item;
      const rect = htmlItem.getBoundingClientRect();
      const viewportHeight = window.innerHeight;
      const isInViewport = rect.top < viewportHeight && rect.bottom > 0;

      // Only observe elements not in initial viewport
      if (!isInViewport) {
        workObserver.observe(htmlItem);
      }
    });
  }

  // Handle work menu animations
  document.addEventListener("astro:page-load", () => {
    setTimeout(() => {
      animateWorkMenu();
      setupWorkObserver();
    }, 200); // Small delay to ensure DOM is ready
  });

  // Initial page load
  setTimeout(() => {
    animateWorkMenu();
    setupWorkObserver();
  }, 100);
</script>
