---
export interface Props {
  text: string;
  class?: string;
  style?: string;
}

const { text, class: className = "", style = "" } = Astro.props;

function groupTextForLigatures(input: string): string[] {
  const groups: string[] = [];
  for (let i = 0; i < input.length; i++) {
    const current = input[i];
    const next = input[i + 1] ?? "";
    // Preserve spaces as individual tokens; will render as nbsp later
    if (current === " ") {
      groups.push(current);
      continue;
    }
    // Keep "ph" together (case-insensitive) to preserve ligature in Sophillia
    if (
      (current === "p" || current === "P") &&
      (next === "h" || next === "H")
    ) {
      groups.push(current + next);
      i++; // Skip the next character since it's grouped
      continue;
    }
    groups.push(current);
  }
  return groups;
}

const groupedText = groupTextForLigatures(text);
---

<div class={`jumbo-text-container ${className}`} style={style}>
  <div class="jumbo-text-element" data-text={text}>
    {
      groupedText.map((unit, index) => (
        <span
          class="jumbo-char"
          data-unit={unit.toLowerCase()}
          style={`animation-delay: ${index * 0.1}s`}
        >
          {unit === " " ? "\u00A0" : unit}
        </span>
      ))
    }
  </div>
</div>

<script>
  // Store resize observers in a WeakMap to avoid memory leaks
  const resizeObservers = new WeakMap<HTMLElement, ResizeObserver>();

  // State to track if this is the initial page load
  let isInitialLoad = true;
  let hasAnimatedOnMobile = false;
  let hasAnimatedOnMd = false;
  let isAnimating = false;

  function calculateOptimalFontSize(element: HTMLElement) {
    const text = element.dataset.text;
    if (!text || !text.trim()) return;

    const container = element.parentElement;
    if (!container || container.offsetWidth <= 0) return;

    const containerWidth = container.offsetWidth;

    // Start with a reasonable font size
    element.style.fontSize = "16px";

    // Binary search for optimal font size
    let minSize = 1;
    let maxSize = 500;
    const precision = 0.5;

    // Initial guess
    let fontSize = Math.min(
      maxSize,
      Math.sqrt(containerWidth) * (12 / Math.sqrt(Math.max(1, text.length)))
    );

    // Test initial size
    if (checkOverflow(element, fontSize, containerWidth)) {
      maxSize = fontSize;
    } else {
      minSize = fontSize;
    }

    // Binary search
    let iterations = 0;
    const MAX_ITERATIONS = 20;

    while (maxSize - minSize > precision && iterations < MAX_ITERATIONS) {
      fontSize = (minSize + maxSize) / 2;

      if (checkOverflow(element, fontSize, containerWidth)) {
        maxSize = fontSize;
      } else {
        minSize = fontSize;
      }

      iterations++;
    }

    // Apply the final size with a small safety margin
    element.style.fontSize = `${minSize * 0.98}px`;
  }

  function checkOverflow(
    element: HTMLElement,
    fontSize: number,
    containerWidth: number
  ): boolean {
    element.style.fontSize = `${fontSize}px`;
    return element.scrollWidth > containerWidth;
  }

  // Debounced resize function with better performance
  let resizeTimeout: ReturnType<typeof setTimeout> | undefined;
  let lastWidth = 0;

  function debouncedResize(element: HTMLElement) {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      const currentWidth = element.parentElement?.offsetWidth || 0;
      // Only recalculate if width actually changed significantly
      if (Math.abs(currentWidth - lastWidth) > 10) {
        lastWidth = currentWidth;
        calculateOptimalFontSize(element);
      }
    }, 150); // Slightly longer delay for better performance
  }

  // Cleanup function for timeouts
  function cleanupTimeouts() {
    clearTimeout(resizeTimeout);
  }

  function initJumboText() {
    const elements = document.querySelectorAll(
      ".jumbo-text-element"
    ) as NodeListOf<HTMLElement>;
    elements.forEach((element) => {
      // Remove existing resize observers if any
      const existingObserver = resizeObservers.get(element);
      if (existingObserver) {
        existingObserver.disconnect();
        resizeObservers.delete(element);
      }

      // Always recalculate font size for view transitions
      calculateOptimalFontSize(element);

      // Set up resize observer with debouncing
      if (window.ResizeObserver) {
        const resizeObserver = new ResizeObserver(() => {
          debouncedResize(element);
        });
        resizeObserver.observe(element.parentElement!);
        resizeObservers.set(element, resizeObserver);
      }
    });
  }

  // Initialize on DOM ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initJumboText);
  } else {
    initJumboText();
  }

  // Handle Astro view transitions
  document.addEventListener("astro:page-load", initJumboText);
  document.addEventListener("astro:after-swap", initJumboText);

  // Also initialize for dynamically added content
  if (typeof window !== "undefined") {
    (window as any).initJumboText = initJumboText;
  }

  // Trigger character animations
  function triggerCharAnimation() {
    if (isAnimating) return; // Prevent multiple simultaneous animations

    const chars = document.querySelectorAll(".jumbo-char");
    const width = window.innerWidth;
    const isMobile = width < 768;
    const isMd = width >= 768 && width < 1024;

    // On mobile and md, only animate on initial page load
    if ((isMobile && hasAnimatedOnMobile) || (isMd && hasAnimatedOnMd)) {
      // Reset animation state for mobile - show immediately
      chars.forEach((char) => {
        (char as HTMLElement).style.animationDelay = "0s";
        (char as HTMLElement).style.opacity = "1";
        (char as HTMLElement).style.transform = "translateX(0)";
      });
      return;
    }

    isAnimating = true;

    chars.forEach((char, index) => {
      const delay = isMobile || isMd ? index * 0.08 : index * 0.035;
      (char as HTMLElement).style.animationDelay = `${delay}s`;
    });

    // Mark mobile/md as animated after first time
    if (isMobile) {
      hasAnimatedOnMobile = true;
    }
    if (isMd) {
      hasAnimatedOnMd = true;
    }

    // Reset animation flag after animation completes
    setTimeout(() => {
      isAnimating = false;
    }, 2000); // Wait for animation to complete
  }

  // Trigger on page load and view transitions
  document.addEventListener("astro:page-load", () => {
    cleanupTimeouts();
    triggerCharAnimation();
  });

  // Initial load trigger
  setTimeout(triggerCharAnimation, 100);
</script>

<style>
  .jumbo-text-container {
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .jumbo-text-element {
    display: block;
    font-family: inherit;
    color: inherit;
    font-weight: inherit;
    letter-spacing: -0.04em;
    line-height: 1;
    text-align: center;
    white-space: nowrap;
    width: 100%;
    will-change: font-size;
    overflow: visible;
  }

  .jumbo-char {
    display: inline-block;
    opacity: 0;
    transform: translate3d(-5px, 0px, 0px);
    animation: charFadeIn 0.8s ease-out forwards;
    will-change: opacity, transform;
  }

  /* Enhanced animation on medium screens and larger */
  @media (min-width: 768px) {
    .jumbo-char {
      opacity: 0;
      transform: translate3d(-10px, 0, 0);
      animation: charFadeIn 0.4s ease-out forwards;
      will-change: opacity, transform;
    }
  }

  @keyframes charFadeIn {
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }

  /* Fine-tune baseline for specific ligature units */
  .jumbo-char[data-unit="ph"] {
    vertical-align: 1px;
  }
</style>
