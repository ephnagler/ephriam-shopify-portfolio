---
export interface Props {
  text: string;
  class?: string;
  style?: string;
}

const { text, class: className = "", style = "" } = Astro.props;
---

<div class={`jumbo-text-container ${className}`} style={style}>
  <div class="jumbo-text-element" data-text={text}>
    {text}
  </div>
</div>

<script>
  // Store resize observers in a WeakMap to avoid memory leaks
  const resizeObservers = new WeakMap<HTMLElement, ResizeObserver>();

  function calculateOptimalFontSize(element: HTMLElement) {
    const text = element.dataset.text;
    if (!text || !text.trim()) return;

    const container = element.parentElement;
    if (!container || container.offsetWidth <= 0) return;

    const containerWidth = container.offsetWidth;

    // Start with a reasonable font size
    element.style.fontSize = "16px";

    // Binary search for optimal font size
    let minSize = 1;
    let maxSize = 500;
    const precision = 0.5;

    // Initial guess
    let fontSize = Math.min(
      maxSize,
      Math.sqrt(containerWidth) * (12 / Math.sqrt(Math.max(1, text.length)))
    );

    // Test initial size
    if (checkOverflow(element, fontSize, containerWidth)) {
      maxSize = fontSize;
    } else {
      minSize = fontSize;
    }

    // Binary search
    let iterations = 0;
    const MAX_ITERATIONS = 20;

    while (maxSize - minSize > precision && iterations < MAX_ITERATIONS) {
      fontSize = (minSize + maxSize) / 2;

      if (checkOverflow(element, fontSize, containerWidth)) {
        maxSize = fontSize;
      } else {
        minSize = fontSize;
      }

      iterations++;
    }

    // Apply the final size with a small safety margin
    element.style.fontSize = `${minSize * 0.98}px`;
  }

  function checkOverflow(
    element: HTMLElement,
    fontSize: number,
    containerWidth: number
  ): boolean {
    element.style.fontSize = `${fontSize}px`;
    return element.scrollWidth > containerWidth;
  }

  function initJumboText() {
    const elements = document.querySelectorAll(
      ".jumbo-text-element"
    ) as NodeListOf<HTMLElement>;
    elements.forEach((element) => {
      // Remove existing resize observers if any
      const existingObserver = resizeObservers.get(element);
      if (existingObserver) {
        existingObserver.disconnect();
        resizeObservers.delete(element);
      }

      // Always recalculate font size for view transitions
      calculateOptimalFontSize(element);

      // Set up resize observer
      if (window.ResizeObserver) {
        const resizeObserver = new ResizeObserver(() => {
          calculateOptimalFontSize(element);
        });
        resizeObserver.observe(element.parentElement!);
        resizeObservers.set(element, resizeObserver);
      }
    });
  }

  // Initialize on DOM ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initJumboText);
  } else {
    initJumboText();
  }

  // Handle Astro view transitions
  document.addEventListener("astro:page-load", initJumboText);
  document.addEventListener("astro:after-swap", initJumboText);

  // Also initialize for dynamically added content
  if (typeof window !== "undefined") {
    (window as any).initJumboText = initJumboText;
  }
</script>

<style>
  .jumbo-text-container {
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .jumbo-text-element {
    display: block;
    font-family: inherit;
    color: inherit;
    font-weight: inherit;
    letter-spacing: -0.04em;
    line-height: 1;
    text-align: center;
    white-space: nowrap;
    width: 100%;
    will-change: font-size;
    overflow: visible;
  }
</style>
